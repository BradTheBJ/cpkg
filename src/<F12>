const std = @import("std");
const c = @cImport({
    @cInclude("stdio.h");
    @cInclude("string.h");
    @cInclude("readLine.h");
});

pub fn buildPackage(packageName: []const u8) !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var externalDir = try std.fs.cwd().openDir("cpkgExternal", .{ .iterate = true });
    defer externalDir.close();

    var packageDir = try externalDir.openDir(packageName, .{ .iterate = true });
    defer packageDir.close();

    var configureCmakeNinja = std.process.Child.init(&[_][]const u8{
        "cmake",
        "-S", ".",
        "-B", "build",
        "-G", "Ninja",
    }, allocator);
    configureCmakeNinja.cwd_dir = packageDir;

    const cterm = try configureCmakeNinja.spawnAndWait();

    if (cterm.Exited != 0) {
        while (true) {
            std.debug.print("Ninja not found, continue with CMake build? [Y/N] ", .{});

            const cStr: [*c]u8 = c.readLine();

            const len_usize: usize = @intCast(c.strlen(cStr));
            if (len_usize > std.math.maxInt(u8)) {
                std.debug.print("Input too long\n", .{});
                continue;
            }
            const len: u8 = @intCast(len_usize);

            var inputLine: []u8 = cStr[0..@as(usize, len)];

            if (len > 0 and inputLine[len - 1] == '\n') {
                inputLine = inputLine[0..@as(usize, len - 1)];
            }

            for (inputLine) |u8| {
                c.* = std.ascii.toLower(c.*);
            }


            if (std.mem.eql(u8, inputLine, "y") or std.mem.eql(u8, inputLine, "yes")) {
                var fallback_cfg = std.process.Child.init(&[_][]const u8{
                    "cmake",
                    "-S", ".",
                    "-B", "build",
                }, allocator);
                fallback_cfg.cwd_dir = packageDir;
                _ = try fallback_cfg.spawnAndWait();
                break;
            }

            if (std.mem.eql(u8, inputLine, "n") or std.mem.eql(u8, inputLine, "no")) {
                return error.NinjaNotFound;
            }

            std.debug.print("Invalid input, please enter 'y' or 'n'.\n", .{});
        }
    }

    var build = std.process.Child.init(&[_][]const u8{
        "cmake",
        "--build", "build",
    }, allocator);
    build.cwd_dir = packageDir;

    const bterm = try build.spawnAndWait();
    if (bterm.Exited != 0) {
        return error.CMakeBuildFailed;
    }
}

